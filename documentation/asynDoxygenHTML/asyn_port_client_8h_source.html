<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>asyn: /home/epics/devel/asynR4-25/asyn/asynPortClient/asynPortClient.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">asyn&#160;<span id="projectnumber">4-25</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<div class="title">/home/epics/devel/asynR4-25/asyn/asynPortClient/asynPortClient.h</div>  </div>
</div>
<div class="contents">
<a href="asyn_port_client_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#ifndef asynPortClient_H</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor">#define asynPortClient_H</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span>
<a name="l00004"></a>00004 <span class="preprocessor">#include &lt;stdexcept&gt;</span>
<a name="l00005"></a>00005 
<a name="l00006"></a>00006 <span class="preprocessor">#include &lt;epicsString.h&gt;</span>
<a name="l00007"></a>00007 
<a name="l00008"></a>00008 <span class="preprocessor">#include &lt;asynDriver.h&gt;</span>
<a name="l00009"></a>00009 <span class="preprocessor">#include &lt;asynInt32.h&gt;</span>
<a name="l00010"></a>00010 <span class="preprocessor">#include &lt;asynInt32SyncIO.h&gt;</span>
<a name="l00011"></a>00011 <span class="preprocessor">#include &lt;asynUInt32Digital.h&gt;</span>
<a name="l00012"></a>00012 <span class="preprocessor">#include &lt;asynUInt32DigitalSyncIO.h&gt;</span>
<a name="l00013"></a>00013 <span class="preprocessor">#include &lt;asynFloat64.h&gt;</span>
<a name="l00014"></a>00014 <span class="preprocessor">#include &lt;asynFloat64SyncIO.h&gt;</span>
<a name="l00015"></a>00015 <span class="preprocessor">#include &lt;asynOctet.h&gt;</span>
<a name="l00016"></a>00016 <span class="preprocessor">#include &lt;asynOctetSyncIO.h&gt;</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include &lt;asynInt8Array.h&gt;</span>
<a name="l00018"></a>00018 <span class="preprocessor">#include &lt;asynInt8ArraySyncIO.h&gt;</span>
<a name="l00019"></a>00019 <span class="preprocessor">#include &lt;asynInt16Array.h&gt;</span>
<a name="l00020"></a>00020 <span class="preprocessor">#include &lt;asynInt16ArraySyncIO.h&gt;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &lt;asynInt32Array.h&gt;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &lt;asynInt32ArraySyncIO.h&gt;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;asynFloat32Array.h&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;asynFloat32ArraySyncIO.h&gt;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;asynFloat64Array.h&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;asynFloat64ArraySyncIO.h&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;asynGenericPointer.h&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;asynGenericPointerSyncIO.h&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;asynEnum.h&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;asynEnumSyncIO.h&gt;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &lt;asynOption.h&gt;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &lt;asynOptionSyncIO.h&gt;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &lt;asynCommonSyncIO.h&gt;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &lt;asynDrvUser.h&gt;</span>
<a name="l00035"></a>00035 
<a name="l00036"></a><a class="code" href="asyn_port_client_8h.html#aad2dd72565852b91c809cd4685833b17">00036</a> <span class="preprocessor">#define DEFAULT_TIMEOUT 1.0</span>
<a name="l00037"></a>00037 <span class="preprocessor"></span>
<a name="l00038"></a>00038 
<a name="l00041"></a><a class="code" href="classasyn_port_client.html">00041</a> <span class="keyword">class </span>epicsShareClass <a class="code" href="classasyn_port_client.html" title="Base class for asyn port clients; handles most of the bookkeeping for writing an asyn port client wit...">asynPortClient</a> {
<a name="l00042"></a>00042 <span class="keyword">public</span>:
<a name="l00043"></a>00043     <a class="code" href="classasyn_port_client.html" title="Base class for asyn port clients; handles most of the bookkeeping for writing an asyn port client wit...">asynPortClient</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *portName, <span class="keywordtype">int</span> addr, <span class="keyword">const</span> <span class="keywordtype">char</span>* asynInterfaceType, <span class="keyword">const</span> <span class="keywordtype">char</span> *drvInfo, <span class="keywordtype">double</span> timeout);
<a name="l00044"></a>00044     <span class="keyword">virtual</span> ~<a class="code" href="classasyn_port_client.html" title="Base class for asyn port clients; handles most of the bookkeeping for writing an asyn port client wit...">asynPortClient</a>();
<a name="l00045"></a><a class="code" href="classasyn_port_client.html#ae8e56e544f32d1337355fd72cfc3aa12">00045</a>     <span class="keywordtype">void</span> setTimeout(<span class="keywordtype">double</span> timeout)
<a name="l00046"></a>00046         { timeout_ = timeout; };
<a name="l00047"></a>00047     <span class="keywordtype">void</span> report(FILE *fp, <span class="keywordtype">int</span> details);
<a name="l00048"></a>00048 <span class="keyword">protected</span>:
<a name="l00049"></a><a class="code" href="classasyn_port_client.html#a3c4d3a8db273e7985aafe2cc60a9128c">00049</a>     asynUser *<a class="code" href="classasyn_port_client.html#a3c4d3a8db273e7985aafe2cc60a9128c">pasynUser_</a>;
<a name="l00050"></a><a class="code" href="classasyn_port_client.html#ad8b0e7fdd10390692d2a2557397ead61">00050</a>     asynUser *<a class="code" href="classasyn_port_client.html#ad8b0e7fdd10390692d2a2557397ead61">pasynUserSyncIO_</a>;
<a name="l00051"></a><a class="code" href="classasyn_port_client.html#a82629ab1890f24de6a9b3a238fd79577">00051</a>     asynInterface *<a class="code" href="classasyn_port_client.html#a82629ab1890f24de6a9b3a238fd79577">pasynInterface_</a>;
<a name="l00052"></a><a class="code" href="classasyn_port_client.html#a5442945ae4b4184d09206ea097943941">00052</a>     <span class="keywordtype">double</span> <a class="code" href="classasyn_port_client.html#a5442945ae4b4184d09206ea097943941">timeout_</a>;
<a name="l00053"></a><a class="code" href="classasyn_port_client.html#a1049f72aefeed69658e4df53ba1e8efc">00053</a>     <span class="keywordtype">char</span> *<a class="code" href="classasyn_port_client.html#a1049f72aefeed69658e4df53ba1e8efc">portName_</a>;
<a name="l00054"></a><a class="code" href="classasyn_port_client.html#a4817204f981defe8e076913d15f18e1e">00054</a>     <span class="keywordtype">int</span> <a class="code" href="classasyn_port_client.html#a4817204f981defe8e076913d15f18e1e">addr_</a>;
<a name="l00055"></a><a class="code" href="classasyn_port_client.html#a17b07e3e949e1be63cdf6a0069211450">00055</a>     <span class="keywordtype">char</span> *<a class="code" href="classasyn_port_client.html#a17b07e3e949e1be63cdf6a0069211450">asynInterfaceType_</a>;
<a name="l00056"></a><a class="code" href="classasyn_port_client.html#aa8a8b92aece35485bca305e62ba427ae">00056</a>     <span class="keywordtype">char</span> *<a class="code" href="classasyn_port_client.html#aa8a8b92aece35485bca305e62ba427ae">drvInfo_</a>;
<a name="l00057"></a><a class="code" href="classasyn_port_client.html#a672aff8918963c8ce5f6cc21a9423da4">00057</a>     <span class="keywordtype">void</span> *<a class="code" href="classasyn_port_client.html#a672aff8918963c8ce5f6cc21a9423da4">drvPvt</a>;
<a name="l00058"></a><a class="code" href="classasyn_port_client.html#a4b6475ffb7ee2ee2be927da5bd0de6cf">00058</a>     <span class="keywordtype">void</span> *<a class="code" href="classasyn_port_client.html#a4b6475ffb7ee2ee2be927da5bd0de6cf">interruptPvt_</a>;
<a name="l00059"></a>00059 };
<a name="l00060"></a>00060 
<a name="l00061"></a>00061 
<a name="l00063"></a><a class="code" href="classasyn_int32_client.html">00063</a> <span class="keyword">class </span>epicsShareClass <a class="code" href="classasyn_int32_client.html" title="Class for asyn port clients to communicate on the asynInt32 interface.">asynInt32Client</a> : <span class="keyword">public</span> <a class="code" href="classasyn_port_client.html" title="Base class for asyn port clients; handles most of the bookkeeping for writing an asyn port client wit...">asynPortClient</a> {
<a name="l00064"></a>00064 <span class="keyword">public</span>:
<a name="l00071"></a><a class="code" href="classasyn_int32_client.html#a0d2bc5168c2253748c6b2f9c7f746d65">00071</a>     <a class="code" href="classasyn_int32_client.html" title="Class for asyn port clients to communicate on the asynInt32 interface.">asynInt32Client</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *portName, <span class="keywordtype">int</span> addr, <span class="keyword">const</span> <span class="keywordtype">char</span> *drvInfo, <span class="keywordtype">double</span> timeout=<a class="code" href="asyn_port_client_8h.html#aad2dd72565852b91c809cd4685833b17">DEFAULT_TIMEOUT</a>)
<a name="l00072"></a>00072     : <a class="code" href="classasyn_port_client.html" title="Base class for asyn port clients; handles most of the bookkeeping for writing an asyn port client wit...">asynPortClient</a>(portName, addr, asynInt32Type, drvInfo, timeout) {
<a name="l00073"></a>00073         pInterface_ = (asynInt32 *)pasynInterface_-&gt;pinterface;
<a name="l00074"></a>00074         if (pasynInt32SyncIO-&gt;connect(portName, addr, &amp;pasynUserSyncIO_, drvInfo)) 
<a name="l00075"></a>00075             <span class="keywordflow">throw</span> std::runtime_error(std::string(<span class="stringliteral">&quot;pasynInt32SyncIO-&gt;connect failed&quot;</span>));
<a name="l00076"></a>00076     };
<a name="l00078"></a><a class="code" href="classasyn_int32_client.html#a28c62336551d78d1483c20486a466716">00078</a>     <span class="keyword">virtual</span> <a class="code" href="classasyn_int32_client.html#a28c62336551d78d1483c20486a466716" title="Destructor for asynInt32Client class.">~asynInt32Client</a>() { 
<a name="l00079"></a>00079         pasynInt32SyncIO-&gt;disconnect(pasynUserSyncIO_); 
<a name="l00080"></a>00080     }; 
<a name="l00083"></a><a class="code" href="classasyn_int32_client.html#a0175597044764900522f2f2b53584b73">00083</a>     <span class="keyword">virtual</span> asynStatus <a class="code" href="classasyn_int32_client.html#a0175597044764900522f2f2b53584b73" title="Reads an epicsInt32 value from the port driver.">read</a>(epicsInt32 *value) { 
<a name="l00084"></a>00084         <span class="keywordflow">return</span> pasynInt32SyncIO-&gt;read(pasynUserSyncIO_, value, timeout_);
<a name="l00085"></a>00085     };
<a name="l00088"></a><a class="code" href="classasyn_int32_client.html#a351be8c7ab2f695579ad9dc21b6e4232">00088</a>     <span class="keyword">virtual</span> asynStatus <a class="code" href="classasyn_int32_client.html#a351be8c7ab2f695579ad9dc21b6e4232" title="Writes an epicsInt32 value to the port driver.">write</a>(epicsInt32 value) { 
<a name="l00089"></a>00089         <span class="keywordflow">return</span> pasynInt32SyncIO-&gt;write(pasynUserSyncIO_, value, timeout_); 
<a name="l00090"></a>00090     };
<a name="l00094"></a><a class="code" href="classasyn_int32_client.html#a2083fa24a5fbd99a84b3765ab82df35c">00094</a>     <span class="keyword">virtual</span> asynStatus <a class="code" href="classasyn_int32_client.html#a2083fa24a5fbd99a84b3765ab82df35c" title="Returns the lower and upper limits of the range of values from the port driver.">getBounds</a>(epicsInt32 *low, epicsInt32 *high) { 
<a name="l00095"></a>00095         <span class="keywordflow">return</span> pasynInt32SyncIO-&gt;getBounds(pasynUserSyncIO_, low, high); 
<a name="l00096"></a>00096     };
<a name="l00099"></a><a class="code" href="classasyn_int32_client.html#a2c5be4bbaff53f04dfafd302c16a5cda">00099</a>     <span class="keyword">virtual</span> asynStatus <a class="code" href="classasyn_int32_client.html#a2c5be4bbaff53f04dfafd302c16a5cda" title="Registers an interruptCallbackInt32 function that the driver will call when there is a new value...">registerInterruptUser</a>(interruptCallbackInt32 pCallback) { 
<a name="l00100"></a>00100         <span class="keywordflow">return</span> pInterface_-&gt;registerInterruptUser(pasynInterface_-&gt;drvPvt, pasynUser_,
<a name="l00101"></a>00101                                                   pCallback, <span class="keyword">this</span>, &amp;interruptPvt_); 
<a name="l00102"></a>00102     };
<a name="l00103"></a>00103 <span class="keyword">private</span>:
<a name="l00104"></a>00104     asynInt32 *pInterface_;
<a name="l00105"></a>00105 };
<a name="l00106"></a>00106 
<a name="l00107"></a>00107 
<a name="l00109"></a><a class="code" href="classasyn_u_int32_digital_client.html">00109</a> <span class="keyword">class </span>epicsShareClass <a class="code" href="classasyn_u_int32_digital_client.html" title="Class for asyn port clients to communicate on the asynUInt32Digital interface.">asynUInt32DigitalClient</a> : <span class="keyword">public</span> <a class="code" href="classasyn_port_client.html" title="Base class for asyn port clients; handles most of the bookkeeping for writing an asyn port client wit...">asynPortClient</a> {
<a name="l00110"></a>00110 <span class="keyword">public</span>:
<a name="l00117"></a><a class="code" href="classasyn_u_int32_digital_client.html#ace4faa3946b0a4e220cd450321ee28b2">00117</a>     <a class="code" href="classasyn_u_int32_digital_client.html" title="Class for asyn port clients to communicate on the asynUInt32Digital interface.">asynUInt32DigitalClient</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *portName, <span class="keywordtype">int</span> addr, <span class="keyword">const</span> <span class="keywordtype">char</span> *drvInfo, <span class="keywordtype">double</span> timeout=<a class="code" href="asyn_port_client_8h.html#aad2dd72565852b91c809cd4685833b17">DEFAULT_TIMEOUT</a>)
<a name="l00118"></a>00118     : <a class="code" href="classasyn_port_client.html" title="Base class for asyn port clients; handles most of the bookkeeping for writing an asyn port client wit...">asynPortClient</a>(portName, addr, asynUInt32DigitalType, drvInfo, timeout) {
<a name="l00119"></a>00119         pInterface_ = (asynUInt32Digital *)pasynInterface_-&gt;pinterface;
<a name="l00120"></a>00120         if (pasynInt32SyncIO-&gt;connect(portName, addr, &amp;pasynUserSyncIO_, drvInfo))
<a name="l00121"></a>00121             <span class="keywordflow">throw</span> std::runtime_error(std::string(<span class="stringliteral">&quot;pasynInt32SyncIO-&gt;connect failed&quot;</span>));
<a name="l00122"></a>00122     };
<a name="l00124"></a><a class="code" href="classasyn_u_int32_digital_client.html#ac90d207abb906f3d8b1407d47fb472cb">00124</a>     <span class="keyword">virtual</span> <a class="code" href="classasyn_u_int32_digital_client.html#ac90d207abb906f3d8b1407d47fb472cb" title="Destructor for asynInt32Client class.">~asynUInt32DigitalClient</a>() {
<a name="l00125"></a>00125         pasynUInt32DigitalSyncIO-&gt;disconnect(pasynUserSyncIO_); 
<a name="l00126"></a>00126     }; 
<a name="l00130"></a><a class="code" href="classasyn_u_int32_digital_client.html#ac20b3ad1fddc5f54227c33cee4845424">00130</a>     <span class="keyword">virtual</span> asynStatus <a class="code" href="classasyn_u_int32_digital_client.html#ac20b3ad1fddc5f54227c33cee4845424" title="Reads an epicsUInt32 value from the port driver.">read</a>(epicsUInt32 *value, epicsUInt32 mask) { 
<a name="l00131"></a>00131         <span class="keywordflow">return</span> pasynUInt32DigitalSyncIO-&gt;read(pasynUserSyncIO_, value, mask, timeout_); 
<a name="l00132"></a>00132     };
<a name="l00136"></a><a class="code" href="classasyn_u_int32_digital_client.html#ae795e9879b8b09f32061e9b0117c1179">00136</a>     <span class="keyword">virtual</span> asynStatus <a class="code" href="classasyn_u_int32_digital_client.html#ae795e9879b8b09f32061e9b0117c1179" title="Writes an epicsUInt32 value to the port driver.">write</a>(epicsUInt32 value, epicsUInt32 mask){ 
<a name="l00137"></a>00137         <span class="keywordflow">return</span> pasynUInt32DigitalSyncIO-&gt;write(pasynUserSyncIO_, value, mask, timeout_); 
<a name="l00138"></a>00138     };
<a name="l00142"></a><a class="code" href="classasyn_u_int32_digital_client.html#aca8a9c8f944fc752dde5ca284f440374">00142</a>     <span class="keyword">virtual</span> asynStatus <a class="code" href="classasyn_u_int32_digital_client.html#aca8a9c8f944fc752dde5ca284f440374" title="Sets the interrupt mask for the specified interrupt reason in the driver.">setInterrupt</a>(epicsUInt32 mask, interruptReason reason) { 
<a name="l00143"></a>00143         <span class="keywordflow">return</span> pasynUInt32DigitalSyncIO-&gt;setInterrupt(pasynUserSyncIO_, mask, reason, timeout_); 
<a name="l00144"></a>00144     };
<a name="l00147"></a><a class="code" href="classasyn_u_int32_digital_client.html#a37d3a48d292b81c72777290face2e0ef">00147</a>     <span class="keyword">virtual</span> asynStatus <a class="code" href="classasyn_u_int32_digital_client.html#a37d3a48d292b81c72777290face2e0ef" title="Clears the interrupt mask in the driver.">clearInterrupt</a>(epicsUInt32 mask) { 
<a name="l00148"></a>00148         <span class="keywordflow">return</span> pasynUInt32DigitalSyncIO-&gt;clearInterrupt(pasynUserSyncIO_, mask, timeout_); 
<a name="l00149"></a>00149     };
<a name="l00153"></a><a class="code" href="classasyn_u_int32_digital_client.html#ad3194e8ef7eb94d4144a54626cd7e9db">00153</a>     <span class="keyword">virtual</span> asynStatus <a class="code" href="classasyn_u_int32_digital_client.html#ad3194e8ef7eb94d4144a54626cd7e9db" title="Gets the current interrupt mask for the specified reason from the driver.">getInterrupt</a>(epicsUInt32 *mask, interruptReason reason) { 
<a name="l00154"></a>00154         <span class="keywordflow">return</span> pasynUInt32DigitalSyncIO-&gt;getInterrupt(pasynUserSyncIO_, mask, reason, timeout_); 
<a name="l00155"></a>00155     };
<a name="l00159"></a><a class="code" href="classasyn_u_int32_digital_client.html#a7c9e9fc52c777e34562b3067b14fea0f">00159</a>     <span class="keyword">virtual</span> asynStatus <a class="code" href="classasyn_u_int32_digital_client.html#a7c9e9fc52c777e34562b3067b14fea0f" title="Registers an interruptCallbackUInt32Digital function that the driver will call when there is a new va...">registerInterruptUser</a>(interruptCallbackUInt32Digital pCallback, epicsUInt32 mask) { 
<a name="l00160"></a>00160         <span class="keywordflow">return</span> pInterface_-&gt;registerInterruptUser(pasynInterface_-&gt;drvPvt, pasynUser_,
<a name="l00161"></a>00161                                                   pCallback, <span class="keyword">this</span>, mask, &amp;interruptPvt_); 
<a name="l00162"></a>00162     };
<a name="l00163"></a>00163 <span class="keyword">private</span>:
<a name="l00164"></a>00164     asynUInt32Digital *pInterface_;
<a name="l00165"></a>00165 };
<a name="l00166"></a>00166 
<a name="l00167"></a>00167 
<a name="l00169"></a><a class="code" href="classasyn_float64_client.html">00169</a> <span class="keyword">class </span>epicsShareClass <a class="code" href="classasyn_float64_client.html" title="Class for asyn port clients to communicate on the asynFloat64 interface.">asynFloat64Client</a> : <span class="keyword">public</span> <a class="code" href="classasyn_port_client.html" title="Base class for asyn port clients; handles most of the bookkeeping for writing an asyn port client wit...">asynPortClient</a> {
<a name="l00170"></a>00170 <span class="keyword">public</span>:
<a name="l00177"></a><a class="code" href="classasyn_float64_client.html#ac366e3e5c7521115aada555f56416377">00177</a>     <a class="code" href="classasyn_float64_client.html" title="Class for asyn port clients to communicate on the asynFloat64 interface.">asynFloat64Client</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *portName, <span class="keywordtype">int</span> addr, <span class="keyword">const</span> <span class="keywordtype">char</span> *drvInfo, <span class="keywordtype">double</span> timeout=<a class="code" href="asyn_port_client_8h.html#aad2dd72565852b91c809cd4685833b17">DEFAULT_TIMEOUT</a>)
<a name="l00178"></a>00178     : <a class="code" href="classasyn_port_client.html" title="Base class for asyn port clients; handles most of the bookkeeping for writing an asyn port client wit...">asynPortClient</a>(portName, addr, asynFloat64Type, drvInfo, timeout) {
<a name="l00179"></a>00179         pInterface_ = (asynFloat64 *)pasynInterface_-&gt;pinterface;
<a name="l00180"></a>00180         if (pasynFloat64SyncIO-&gt;connect(portName, addr, &amp;pasynUserSyncIO_, drvInfo))
<a name="l00181"></a>00181             <span class="keywordflow">throw</span> std::runtime_error(std::string(<span class="stringliteral">&quot;pasynFloat64SyncIO-&gt;connect failed&quot;</span>));
<a name="l00182"></a>00182     };
<a name="l00184"></a><a class="code" href="classasyn_float64_client.html#a1e7753f16c49b89810c544b65ea5934b">00184</a>     <span class="keyword">virtual</span> <a class="code" href="classasyn_float64_client.html#a1e7753f16c49b89810c544b65ea5934b" title="Destructor for asynFloat64Client class.">~asynFloat64Client</a>() { 
<a name="l00185"></a>00185         pasynFloat64SyncIO-&gt;disconnect(pasynUserSyncIO_); 
<a name="l00186"></a>00186     }; 
<a name="l00189"></a><a class="code" href="classasyn_float64_client.html#aa42aa80bb24d6287ed20b7f3242240df">00189</a>     <span class="keyword">virtual</span> asynStatus <a class="code" href="classasyn_float64_client.html#aa42aa80bb24d6287ed20b7f3242240df" title="Reads an epicsFloat64 value from the port driver.">read</a>(epicsFloat64 *value) {
<a name="l00190"></a>00190         <span class="keywordflow">return</span> pasynFloat64SyncIO-&gt;read(pasynUserSyncIO_, value, timeout_); 
<a name="l00191"></a>00191     };
<a name="l00194"></a><a class="code" href="classasyn_float64_client.html#af69098886f1a4946c1021b4853bd0e35">00194</a>     <span class="keyword">virtual</span> asynStatus <a class="code" href="classasyn_float64_client.html#af69098886f1a4946c1021b4853bd0e35" title="Writes an epicsFloat64 value to the port driver.">write</a>(epicsFloat64 value) { 
<a name="l00195"></a>00195         <span class="keywordflow">return</span> pasynFloat64SyncIO-&gt;write(pasynUserSyncIO_, value, timeout_); 
<a name="l00196"></a>00196     };
<a name="l00199"></a><a class="code" href="classasyn_float64_client.html#a29601146f6a58dffc1cdc06f1c3dfac9">00199</a>     <span class="keyword">virtual</span> asynStatus <a class="code" href="classasyn_float64_client.html#a29601146f6a58dffc1cdc06f1c3dfac9" title="Registers an interruptCallbackFloat64 function that the driver will call when there is a new value...">registerInterruptUser</a>(interruptCallbackFloat64 pCallback) { 
<a name="l00200"></a>00200         <span class="keywordflow">return</span> pInterface_-&gt;registerInterruptUser(pasynInterface_-&gt;drvPvt, pasynUser_,
<a name="l00201"></a>00201                                                   pCallback, <span class="keyword">this</span>, &amp;interruptPvt_); 
<a name="l00202"></a>00202     };
<a name="l00203"></a>00203 <span class="keyword">private</span>:
<a name="l00204"></a>00204     asynFloat64 *pInterface_;
<a name="l00205"></a>00205 };
<a name="l00206"></a>00206 
<a name="l00207"></a>00207 
<a name="l00209"></a><a class="code" href="classasyn_octet_client.html">00209</a> <span class="keyword">class </span>epicsShareClass <a class="code" href="classasyn_octet_client.html" title="Class for asyn port clients to communicate on the asynOctet interface.">asynOctetClient</a> : <span class="keyword">public</span> <a class="code" href="classasyn_port_client.html" title="Base class for asyn port clients; handles most of the bookkeeping for writing an asyn port client wit...">asynPortClient</a> {
<a name="l00210"></a>00210 <span class="keyword">public</span>:
<a name="l00217"></a><a class="code" href="classasyn_octet_client.html#aa8a8f03d36df13f2166d9bc671ce5693">00217</a>     <a class="code" href="classasyn_octet_client.html" title="Class for asyn port clients to communicate on the asynOctet interface.">asynOctetClient</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *portName, <span class="keywordtype">int</span> addr, <span class="keyword">const</span> <span class="keywordtype">char</span> *drvInfo, <span class="keywordtype">double</span> timeout=<a class="code" href="asyn_port_client_8h.html#aad2dd72565852b91c809cd4685833b17">DEFAULT_TIMEOUT</a>)
<a name="l00218"></a>00218     : <a class="code" href="classasyn_port_client.html" title="Base class for asyn port clients; handles most of the bookkeeping for writing an asyn port client wit...">asynPortClient</a>(portName, addr, asynOctetType, drvInfo, timeout) {
<a name="l00219"></a>00219         pInterface_ = (asynOctet *)pasynInterface_-&gt;pinterface;
<a name="l00220"></a>00220         if (pasynOctetSyncIO-&gt;connect(portName, addr, &amp;pasynUserSyncIO_, drvInfo)) 
<a name="l00221"></a>00221             <span class="keywordflow">throw</span> std::runtime_error(std::string(<span class="stringliteral">&quot;pasynOctetSyncIO-&gt;connect failed&quot;</span>));
<a name="l00222"></a>00222     };
<a name="l00224"></a><a class="code" href="classasyn_octet_client.html#aa9747450ae80f7f295f3e46f300ec1a1">00224</a>     <span class="keyword">virtual</span> <a class="code" href="classasyn_octet_client.html#aa9747450ae80f7f295f3e46f300ec1a1" title="Destructor for asynOctetClient class.">~asynOctetClient</a>() { 
<a name="l00225"></a>00225         pasynOctetSyncIO-&gt;disconnect(pasynUserSyncIO_); 
<a name="l00226"></a>00226     }; 
<a name="l00231"></a><a class="code" href="classasyn_octet_client.html#a4e87219ab4a866bf93f4c47cabf618b6">00231</a>     <span class="keyword">virtual</span> asynStatus <a class="code" href="classasyn_octet_client.html#a4e87219ab4a866bf93f4c47cabf618b6" title="Writes a char buffer to the port driver.">write</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *buffer, <span class="keywordtype">size_t</span> bufferLen, <span class="keywordtype">size_t</span> *nActual) { 
<a name="l00232"></a>00232         <span class="keywordflow">return</span> pasynOctetSyncIO-&gt;write(pasynUserSyncIO_, buffer, bufferLen, timeout_, nActual); 
<a name="l00233"></a>00233     };
<a name="l00239"></a><a class="code" href="classasyn_octet_client.html#ac0189580a7225e312abc1e45286cff32">00239</a>     <span class="keyword">virtual</span> asynStatus <a class="code" href="classasyn_octet_client.html#ac0189580a7225e312abc1e45286cff32" title="Reads a char buffer from the port driver.">read</a>(<span class="keywordtype">char</span> *buffer, <span class="keywordtype">size_t</span> bufferLen, <span class="keywordtype">size_t</span> *nActual, <span class="keywordtype">int</span> *eomReason) {
<a name="l00240"></a>00240         <span class="keywordflow">return</span> pasynOctetSyncIO-&gt;read(pasynUserSyncIO_, buffer, bufferLen, timeout_, nActual, eomReason); 
<a name="l00241"></a>00241     };
<a name="l00250"></a><a class="code" href="classasyn_octet_client.html#a2e8b3f40fe7f594564970c40f8c7c604">00250</a>     <span class="keyword">virtual</span> asynStatus writeRead(<span class="keyword">const</span> <span class="keywordtype">char</span> *writeBuffer, <span class="keywordtype">size_t</span> writeBufferLen, <span class="keywordtype">char</span> *readBuffer, <span class="keywordtype">size_t</span> readBufferLen, 
<a name="l00251"></a>00251                                  <span class="keywordtype">size_t</span> *nBytesOut, <span class="keywordtype">size_t</span> *nBytesIn, <span class="keywordtype">int</span> *eomReason) { 
<a name="l00252"></a>00252         <span class="keywordflow">return</span> pasynOctetSyncIO-&gt;writeRead(pasynUserSyncIO_, writeBuffer, writeBufferLen, readBuffer, readBufferLen,
<a name="l00253"></a>00253                                            timeout_, nBytesOut, nBytesIn, eomReason); 
<a name="l00254"></a>00254     };
<a name="l00256"></a><a class="code" href="classasyn_octet_client.html#ac45851f73cec470cd4da788c3dbae1f8">00256</a>     <span class="keyword">virtual</span> asynStatus <a class="code" href="classasyn_octet_client.html#ac45851f73cec470cd4da788c3dbae1f8" title="Flushes the input buffer in the port driver.">flush</a>() { 
<a name="l00257"></a>00257         <span class="keywordflow">return</span> pasynOctetSyncIO-&gt;flush(pasynUserSyncIO_); 
<a name="l00258"></a>00258     };
<a name="l00262"></a><a class="code" href="classasyn_octet_client.html#aac4f6228a878efce342b647aab3fa69b">00262</a>     <span class="keyword">virtual</span> asynStatus <a class="code" href="classasyn_octet_client.html#aac4f6228a878efce342b647aab3fa69b" title="Sets the input end-of-string terminator in the driver.">setInputEos</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *eos, <span class="keywordtype">int</span> eosLen) { 
<a name="l00263"></a>00263         <span class="keywordflow">return</span> pasynOctetSyncIO-&gt;setInputEos(pasynUserSyncIO_, eos, eosLen); 
<a name="l00264"></a>00264     };
<a name="l00269"></a><a class="code" href="classasyn_octet_client.html#ab6212a8fcae8c7b382f5f431a3b1e6e1">00269</a>     <span class="keyword">virtual</span> asynStatus <a class="code" href="classasyn_octet_client.html#ab6212a8fcae8c7b382f5f431a3b1e6e1" title="Gets the input end-of-string terminator from the driver.">getInputEos</a>(<span class="keywordtype">char</span> *eos, <span class="keywordtype">int</span> eosSize, <span class="keywordtype">int</span> *eosLen) { 
<a name="l00270"></a>00270         <span class="keywordflow">return</span> pasynOctetSyncIO-&gt;getInputEos(pasynUserSyncIO_, eos, eosSize, eosLen); 
<a name="l00271"></a>00271     };
<a name="l00275"></a><a class="code" href="classasyn_octet_client.html#a51c6b9e778bd5c0bd91cd965bdbb1d6f">00275</a>     <span class="keyword">virtual</span> asynStatus <a class="code" href="classasyn_octet_client.html#a51c6b9e778bd5c0bd91cd965bdbb1d6f" title="Sets the output end-of-string terminator in the driver.">setOutputEos</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *eos, <span class="keywordtype">int</span> eosLen) { 
<a name="l00276"></a>00276         <span class="keywordflow">return</span> pasynOctetSyncIO-&gt;setOutputEos(pasynUserSyncIO_, eos, eosLen); 
<a name="l00277"></a>00277     };
<a name="l00282"></a><a class="code" href="classasyn_octet_client.html#a72e4aa19641b0ce7ddb139fbf1e299f1">00282</a>     <span class="keyword">virtual</span> asynStatus <a class="code" href="classasyn_octet_client.html#a72e4aa19641b0ce7ddb139fbf1e299f1" title="Gets the output end-of-string terminator from the driver.">getOutputEos</a>(<span class="keywordtype">char</span> *eos, <span class="keywordtype">int</span> eosSize, <span class="keywordtype">int</span> *eosLen) { 
<a name="l00283"></a>00283         <span class="keywordflow">return</span> pasynOctetSyncIO-&gt;getOutputEos(pasynUserSyncIO_, eos, eosSize, eosLen); 
<a name="l00284"></a>00284     };
<a name="l00287"></a><a class="code" href="classasyn_octet_client.html#aa70535421cdb68217dfda7384e25bfb1">00287</a>     <span class="keyword">virtual</span> asynStatus <a class="code" href="classasyn_octet_client.html#aa70535421cdb68217dfda7384e25bfb1" title="Registers an interruptCallbackOctet function that the driver will call when there is a new value...">registerInterruptUser</a>(interruptCallbackOctet pCallback) { 
<a name="l00288"></a>00288         <span class="keywordflow">return</span> pInterface_-&gt;registerInterruptUser(pasynInterface_-&gt;drvPvt, pasynUser_,
<a name="l00289"></a>00289                                                   pCallback, <span class="keyword">this</span>, &amp;interruptPvt_); 
<a name="l00290"></a>00290     };
<a name="l00291"></a>00291 <span class="keyword">private</span>:
<a name="l00292"></a>00292     asynOctet *pInterface_;
<a name="l00293"></a>00293 };
<a name="l00294"></a>00294   
<a name="l00295"></a>00295 
<a name="l00297"></a><a class="code" href="classasyn_int8_array_client.html">00297</a> <span class="keyword">class </span>epicsShareClass <a class="code" href="classasyn_int8_array_client.html" title="Class for asyn port clients to communicate on the asynInt8Array interface.">asynInt8ArrayClient</a> : <span class="keyword">public</span> <a class="code" href="classasyn_port_client.html" title="Base class for asyn port clients; handles most of the bookkeeping for writing an asyn port client wit...">asynPortClient</a> {
<a name="l00298"></a>00298 <span class="keyword">public</span>:
<a name="l00305"></a><a class="code" href="classasyn_int8_array_client.html#a7e051350779fe9a5620b244f144550d9">00305</a>     <a class="code" href="classasyn_int8_array_client.html" title="Class for asyn port clients to communicate on the asynInt8Array interface.">asynInt8ArrayClient</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *portName, <span class="keywordtype">int</span> addr, <span class="keyword">const</span> <span class="keywordtype">char</span> *drvInfo, <span class="keywordtype">double</span> timeout=<a class="code" href="asyn_port_client_8h.html#aad2dd72565852b91c809cd4685833b17">DEFAULT_TIMEOUT</a>)
<a name="l00306"></a>00306     : <a class="code" href="classasyn_port_client.html" title="Base class for asyn port clients; handles most of the bookkeeping for writing an asyn port client wit...">asynPortClient</a>(portName, addr, asynInt8ArrayType, drvInfo, timeout) {
<a name="l00307"></a>00307         pInterface_ = (asynInt8Array *)pasynInterface_-&gt;pinterface;
<a name="l00308"></a>00308         if (pasynInt8ArraySyncIO-&gt;connect(portName, addr, &amp;pasynUserSyncIO_, drvInfo)) 
<a name="l00309"></a>00309             <span class="keywordflow">throw</span> std::runtime_error(std::string(<span class="stringliteral">&quot;pasynInt8ArraySyncIO-&gt;connect failed&quot;</span>));
<a name="l00310"></a>00310     };
<a name="l00312"></a><a class="code" href="classasyn_int8_array_client.html#a7c45062174a13c7e543d7d31dfb657f5">00312</a>     <span class="keyword">virtual</span> <a class="code" href="classasyn_int8_array_client.html#a7c45062174a13c7e543d7d31dfb657f5" title="Destructor for asynInt8Array class.">~asynInt8ArrayClient</a>() {
<a name="l00313"></a>00313         pasynInt8ArraySyncIO-&gt;disconnect(pasynUserSyncIO_);
<a name="l00314"></a>00314     };
<a name="l00319"></a><a class="code" href="classasyn_int8_array_client.html#a2459c45171b797c48bc66bbc1448ecbc">00319</a>     <span class="keyword">virtual</span> asynStatus <a class="code" href="classasyn_int8_array_client.html#a2459c45171b797c48bc66bbc1448ecbc" title="Reads an epicsInt8 array from the port driver.">read</a>(epicsInt8 *value, <span class="keywordtype">size_t</span> nElements, <span class="keywordtype">size_t</span> *nIn) {
<a name="l00320"></a>00320         <span class="keywordflow">return</span> pasynInt8ArraySyncIO-&gt;read(pasynUserSyncIO_, value, nElements, nIn, timeout_);
<a name="l00321"></a>00321     };
<a name="l00325"></a><a class="code" href="classasyn_int8_array_client.html#a9773bf57e365d17595901dcc12078a43">00325</a>     <span class="keyword">virtual</span> asynStatus <a class="code" href="classasyn_int8_array_client.html#a9773bf57e365d17595901dcc12078a43" title="Writes an epicsInt8 array to the port driver.">write</a>(epicsInt8 *value, <span class="keywordtype">size_t</span> nElements) {
<a name="l00326"></a>00326         <span class="keywordflow">return</span> pasynInt8ArraySyncIO-&gt;write(pasynUserSyncIO_, value, nElements, timeout_);
<a name="l00327"></a>00327     };
<a name="l00330"></a><a class="code" href="classasyn_int8_array_client.html#a31c091f62f5d52787ef25eb9133aed10">00330</a>     <span class="keyword">virtual</span> asynStatus <a class="code" href="classasyn_int8_array_client.html#a31c091f62f5d52787ef25eb9133aed10" title="Registers an interruptCallbackInt8Array function that the driver will call when there is a new value...">registerInterruptUser</a>(interruptCallbackInt8Array pCallback) { 
<a name="l00331"></a>00331         <span class="keywordflow">return</span> pInterface_-&gt;registerInterruptUser(pasynInterface_-&gt;drvPvt, pasynUser_,
<a name="l00332"></a>00332                                                       pCallback, <span class="keyword">this</span>, &amp;interruptPvt_); 
<a name="l00333"></a>00333     };
<a name="l00334"></a>00334 <span class="keyword">private</span>:
<a name="l00335"></a>00335     asynInt8Array *pInterface_;
<a name="l00336"></a>00336 };
<a name="l00337"></a>00337 
<a name="l00338"></a>00338 
<a name="l00340"></a><a class="code" href="classasyn_int16_array_client.html">00340</a> <span class="keyword">class </span>epicsShareClass <a class="code" href="classasyn_int16_array_client.html" title="Class for asyn port clients to communicate on the asynInt16Array interface.">asynInt16ArrayClient</a> : <span class="keyword">public</span> <a class="code" href="classasyn_port_client.html" title="Base class for asyn port clients; handles most of the bookkeeping for writing an asyn port client wit...">asynPortClient</a> {
<a name="l00341"></a>00341 <span class="keyword">public</span>:
<a name="l00348"></a><a class="code" href="classasyn_int16_array_client.html#aa957b32123a1ebc9e8203a8fa6216dd7">00348</a>     <a class="code" href="classasyn_int16_array_client.html" title="Class for asyn port clients to communicate on the asynInt16Array interface.">asynInt16ArrayClient</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *portName, <span class="keywordtype">int</span> addr, <span class="keyword">const</span> <span class="keywordtype">char</span> *drvInfo, <span class="keywordtype">double</span> timeout=<a class="code" href="asyn_port_client_8h.html#aad2dd72565852b91c809cd4685833b17">DEFAULT_TIMEOUT</a>)
<a name="l00349"></a>00349     : <a class="code" href="classasyn_port_client.html" title="Base class for asyn port clients; handles most of the bookkeeping for writing an asyn port client wit...">asynPortClient</a>(portName, addr, asynInt16ArrayType, drvInfo, timeout) {
<a name="l00350"></a>00350         pInterface_ = (asynInt16Array *)pasynInterface_-&gt;pinterface;
<a name="l00351"></a>00351         if (pasynInt16ArraySyncIO-&gt;connect(portName, addr, &amp;pasynUserSyncIO_, drvInfo)) 
<a name="l00352"></a>00352             <span class="keywordflow">throw</span> std::runtime_error(std::string(<span class="stringliteral">&quot;pasynInt16ArraySyncIO-&gt;connect failed&quot;</span>));
<a name="l00353"></a>00353     };
<a name="l00355"></a><a class="code" href="classasyn_int16_array_client.html#af9781ed8ab8db41b3d610a4fccf1784f">00355</a>     <span class="keyword">virtual</span> <a class="code" href="classasyn_int16_array_client.html#af9781ed8ab8db41b3d610a4fccf1784f" title="Destructor for asynInt16Array class.">~asynInt16ArrayClient</a>() {
<a name="l00356"></a>00356         pasynInt16ArraySyncIO-&gt;disconnect(pasynUserSyncIO_);
<a name="l00357"></a>00357     };
<a name="l00362"></a><a class="code" href="classasyn_int16_array_client.html#afd60f6973e95589471082447d58fa1bc">00362</a>     <span class="keyword">virtual</span> asynStatus <a class="code" href="classasyn_int16_array_client.html#afd60f6973e95589471082447d58fa1bc" title="Reads an epicsInt16 array from the port driver.">read</a>(epicsInt16 *value, <span class="keywordtype">size_t</span> nElements, <span class="keywordtype">size_t</span> *nIn) {
<a name="l00363"></a>00363         <span class="keywordflow">return</span> pasynInt16ArraySyncIO-&gt;read(pasynUserSyncIO_, value, nElements, nIn, timeout_);
<a name="l00364"></a>00364     };
<a name="l00368"></a><a class="code" href="classasyn_int16_array_client.html#a038ef28b8876a34d3a23dc7616ba419d">00368</a>     <span class="keyword">virtual</span> asynStatus <a class="code" href="classasyn_int16_array_client.html#a038ef28b8876a34d3a23dc7616ba419d" title="Writes an epicsInt16 array to the port driver.">write</a>(epicsInt16 *value, <span class="keywordtype">size_t</span> nElements) {
<a name="l00369"></a>00369         <span class="keywordflow">return</span> pasynInt16ArraySyncIO-&gt;write(pasynUserSyncIO_, value, nElements, timeout_);
<a name="l00370"></a>00370     };
<a name="l00373"></a><a class="code" href="classasyn_int16_array_client.html#a9adaa6fdc9a2d21b16e0a608a969a891">00373</a>     <span class="keyword">virtual</span> asynStatus <a class="code" href="classasyn_int16_array_client.html#a9adaa6fdc9a2d21b16e0a608a969a891" title="Registers an interruptCallbackInt16Array function that the driver will call when there is a new value...">registerInterruptUser</a>(interruptCallbackInt16Array pCallback) { 
<a name="l00374"></a>00374         <span class="keywordflow">return</span> pInterface_-&gt;registerInterruptUser(pasynInterface_-&gt;drvPvt, pasynUser_,
<a name="l00375"></a>00375                                                        pCallback, <span class="keyword">this</span>, &amp;interruptPvt_); 
<a name="l00376"></a>00376     };
<a name="l00377"></a>00377 <span class="keyword">private</span>:
<a name="l00378"></a>00378     asynInt16Array *pInterface_;
<a name="l00379"></a>00379 };
<a name="l00380"></a>00380 
<a name="l00381"></a>00381 
<a name="l00383"></a><a class="code" href="classasyn_int32_array_client.html">00383</a> <span class="keyword">class </span>epicsShareClass <a class="code" href="classasyn_int32_array_client.html" title="Class for asyn port clients to communicate on the asynInt32Array interface.">asynInt32ArrayClient</a> : <span class="keyword">public</span> <a class="code" href="classasyn_port_client.html" title="Base class for asyn port clients; handles most of the bookkeeping for writing an asyn port client wit...">asynPortClient</a> {
<a name="l00384"></a>00384 <span class="keyword">public</span>:
<a name="l00391"></a><a class="code" href="classasyn_int32_array_client.html#adc2de6b54767dc395153ccfd0f679da7">00391</a>     <a class="code" href="classasyn_int32_array_client.html" title="Class for asyn port clients to communicate on the asynInt32Array interface.">asynInt32ArrayClient</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *portName, <span class="keywordtype">int</span> addr, <span class="keyword">const</span> <span class="keywordtype">char</span> *drvInfo, <span class="keywordtype">double</span> timeout=<a class="code" href="asyn_port_client_8h.html#aad2dd72565852b91c809cd4685833b17">DEFAULT_TIMEOUT</a>)
<a name="l00392"></a>00392     : <a class="code" href="classasyn_port_client.html" title="Base class for asyn port clients; handles most of the bookkeeping for writing an asyn port client wit...">asynPortClient</a>(portName, addr, asynInt32ArrayType, drvInfo, timeout) {
<a name="l00393"></a>00393         pInterface_ = (asynInt32Array *)pasynInterface_-&gt;pinterface;
<a name="l00394"></a>00394         if (pasynInt32ArraySyncIO-&gt;connect(portName, addr, &amp;pasynUserSyncIO_, drvInfo)) 
<a name="l00395"></a>00395             <span class="keywordflow">throw</span> std::runtime_error(std::string(<span class="stringliteral">&quot;pasynInt32ArraySyncIO-&gt;connect failed&quot;</span>));
<a name="l00396"></a>00396     };
<a name="l00398"></a><a class="code" href="classasyn_int32_array_client.html#a56258a003d29d2952157d181aaf0280e">00398</a>     <span class="keyword">virtual</span> <a class="code" href="classasyn_int32_array_client.html#a56258a003d29d2952157d181aaf0280e" title="Destructor for asynInt32Array class.">~asynInt32ArrayClient</a>() {
<a name="l00399"></a>00399         pasynInt32ArraySyncIO-&gt;disconnect(pasynUserSyncIO_);
<a name="l00400"></a>00400     };
<a name="l00405"></a><a class="code" href="classasyn_int32_array_client.html#af0c4ca8d8645415a5deac57552e474f5">00405</a>     <span class="keyword">virtual</span> asynStatus <a class="code" href="classasyn_int32_array_client.html#af0c4ca8d8645415a5deac57552e474f5" title="Reads an epicsInt32 array from the port driver.">read</a>(epicsInt32 *value, <span class="keywordtype">size_t</span> nElements, <span class="keywordtype">size_t</span> *nIn) {
<a name="l00406"></a>00406         <span class="keywordflow">return</span> pasynInt32ArraySyncIO-&gt;read(pasynUserSyncIO_, value, nElements, nIn, timeout_);
<a name="l00407"></a>00407     };
<a name="l00411"></a><a class="code" href="classasyn_int32_array_client.html#acba280c9b316da19cae580eb9aaffbc4">00411</a>     <span class="keyword">virtual</span> asynStatus <a class="code" href="classasyn_int32_array_client.html#acba280c9b316da19cae580eb9aaffbc4" title="Writes an epicsInt32 array to the port driver.">write</a>(epicsInt32 *value, <span class="keywordtype">size_t</span> nElements) {
<a name="l00412"></a>00412         <span class="keywordflow">return</span> pasynInt32ArraySyncIO-&gt;write(pasynUserSyncIO_, value, nElements, timeout_);
<a name="l00413"></a>00413     };
<a name="l00416"></a><a class="code" href="classasyn_int32_array_client.html#aee22864015bb8cc56d30a69a49a05dd3">00416</a>     <span class="keyword">virtual</span> asynStatus <a class="code" href="classasyn_int32_array_client.html#aee22864015bb8cc56d30a69a49a05dd3" title="Registers an interruptCallbackInt32Array function that the driver will call when there is a new value...">registerInterruptUser</a>(interruptCallbackInt32Array pCallback) { 
<a name="l00417"></a>00417         <span class="keywordflow">return</span> pInterface_-&gt;registerInterruptUser(pasynInterface_-&gt;drvPvt, pasynUser_,
<a name="l00418"></a>00418                                                   pCallback, <span class="keyword">this</span>, &amp;interruptPvt_); 
<a name="l00419"></a>00419     };
<a name="l00420"></a>00420 <span class="keyword">private</span>:
<a name="l00421"></a>00421     asynInt32Array *pInterface_;
<a name="l00422"></a>00422 };
<a name="l00423"></a>00423 
<a name="l00424"></a>00424 
<a name="l00426"></a><a class="code" href="classasyn_float32_array_client.html">00426</a> <span class="keyword">class </span>epicsShareClass <a class="code" href="classasyn_float32_array_client.html" title="Class for asyn port clients to communicate on the asynFloat32Array interface.">asynFloat32ArrayClient</a> : <span class="keyword">public</span> <a class="code" href="classasyn_port_client.html" title="Base class for asyn port clients; handles most of the bookkeeping for writing an asyn port client wit...">asynPortClient</a> {
<a name="l00427"></a>00427 <span class="keyword">public</span>:
<a name="l00434"></a><a class="code" href="classasyn_float32_array_client.html#a26a7601a7fb5daf076a265b7bcf8b5bb">00434</a>     <a class="code" href="classasyn_float32_array_client.html" title="Class for asyn port clients to communicate on the asynFloat32Array interface.">asynFloat32ArrayClient</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *portName, <span class="keywordtype">int</span> addr, <span class="keyword">const</span> <span class="keywordtype">char</span> *drvInfo, <span class="keywordtype">double</span> timeout=<a class="code" href="asyn_port_client_8h.html#aad2dd72565852b91c809cd4685833b17">DEFAULT_TIMEOUT</a>)
<a name="l00435"></a>00435     : <a class="code" href="classasyn_port_client.html" title="Base class for asyn port clients; handles most of the bookkeeping for writing an asyn port client wit...">asynPortClient</a>(portName, addr, asynFloat32ArrayType, drvInfo, timeout) {
<a name="l00436"></a>00436         pInterface_ = (asynFloat32Array *)pasynInterface_-&gt;pinterface;
<a name="l00437"></a>00437         if (pasynFloat32ArraySyncIO-&gt;connect(portName, addr, &amp;pasynUserSyncIO_, drvInfo)) 
<a name="l00438"></a>00438             <span class="keywordflow">throw</span> std::runtime_error(std::string(<span class="stringliteral">&quot;pasynFloat64ArraySyncIO-&gt;connect failed&quot;</span>));
<a name="l00439"></a>00439     };
<a name="l00441"></a><a class="code" href="classasyn_float32_array_client.html#a426bd1ddf5de239b01f1660ec00ed56d">00441</a>     <span class="keyword">virtual</span> <a class="code" href="classasyn_float32_array_client.html#a426bd1ddf5de239b01f1660ec00ed56d" title="Destructor for asynFloat32Array class.">~asynFloat32ArrayClient</a>() {
<a name="l00442"></a>00442         pasynFloat32ArraySyncIO-&gt;disconnect(pasynUserSyncIO_);
<a name="l00443"></a>00443     };
<a name="l00448"></a><a class="code" href="classasyn_float32_array_client.html#a9beebe5803c7141b1dba2ef56fb4c65e">00448</a>     <span class="keyword">virtual</span> asynStatus <a class="code" href="classasyn_float32_array_client.html#a9beebe5803c7141b1dba2ef56fb4c65e" title="Reads an epicsFloat32 array from the port driver.">read</a>(epicsFloat32 *value, <span class="keywordtype">size_t</span> nElements, <span class="keywordtype">size_t</span> *nIn) {
<a name="l00449"></a>00449         <span class="keywordflow">return</span> pasynFloat32ArraySyncIO-&gt;read(pasynUserSyncIO_, value, nElements, nIn, timeout_);
<a name="l00450"></a>00450     };
<a name="l00454"></a><a class="code" href="classasyn_float32_array_client.html#a39bf0b8d84d1b94e9c89dfb0a40f3e8a">00454</a>     <span class="keyword">virtual</span> asynStatus <a class="code" href="classasyn_float32_array_client.html#a39bf0b8d84d1b94e9c89dfb0a40f3e8a" title="Writes an epicsFloat32 array to the port driver.">write</a>(epicsFloat32 *value, <span class="keywordtype">size_t</span> nElements) {
<a name="l00455"></a>00455         <span class="keywordflow">return</span> pasynFloat32ArraySyncIO-&gt;write(pasynUserSyncIO_, value, nElements, timeout_);
<a name="l00456"></a>00456     };
<a name="l00459"></a><a class="code" href="classasyn_float32_array_client.html#acf91d27e7f365a09c11fa590021d33e3">00459</a>     <span class="keyword">virtual</span> asynStatus <a class="code" href="classasyn_float32_array_client.html#acf91d27e7f365a09c11fa590021d33e3" title="Registers an interruptCallbackFloat32Array function that the driver will call when there is a new val...">registerInterruptUser</a>(interruptCallbackFloat32Array pCallback) { 
<a name="l00460"></a>00460         <span class="keywordflow">return</span> pInterface_-&gt;registerInterruptUser(pasynInterface_-&gt;drvPvt, pasynUser_,
<a name="l00461"></a>00461                                                   pCallback, <span class="keyword">this</span>, &amp;interruptPvt_); 
<a name="l00462"></a>00462     };
<a name="l00463"></a>00463 <span class="keyword">private</span>:
<a name="l00464"></a>00464     asynFloat32Array *pInterface_;
<a name="l00465"></a>00465 };
<a name="l00466"></a>00466 
<a name="l00467"></a>00467 
<a name="l00469"></a><a class="code" href="classasyn_float64_array_client.html">00469</a> <span class="keyword">class </span>epicsShareClass <a class="code" href="classasyn_float64_array_client.html" title="Class for asyn port clients to communicate on the asynFloat64Array interface.">asynFloat64ArrayClient</a> : <span class="keyword">public</span> <a class="code" href="classasyn_port_client.html" title="Base class for asyn port clients; handles most of the bookkeeping for writing an asyn port client wit...">asynPortClient</a> {
<a name="l00470"></a>00470 <span class="keyword">public</span>:
<a name="l00477"></a><a class="code" href="classasyn_float64_array_client.html#a908f710e1fb3cccf80e9a886f6074233">00477</a>     <a class="code" href="classasyn_float64_array_client.html" title="Class for asyn port clients to communicate on the asynFloat64Array interface.">asynFloat64ArrayClient</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *portName, <span class="keywordtype">int</span> addr, <span class="keyword">const</span> <span class="keywordtype">char</span> *drvInfo, <span class="keywordtype">double</span> timeout=<a class="code" href="asyn_port_client_8h.html#aad2dd72565852b91c809cd4685833b17">DEFAULT_TIMEOUT</a>)
<a name="l00478"></a>00478     : <a class="code" href="classasyn_port_client.html" title="Base class for asyn port clients; handles most of the bookkeeping for writing an asyn port client wit...">asynPortClient</a>(portName, addr, asynFloat64ArrayType, drvInfo, timeout) {
<a name="l00479"></a>00479         pInterface_ = (asynFloat64Array *)pasynInterface_-&gt;pinterface;
<a name="l00480"></a>00480         if (pasynFloat64ArraySyncIO-&gt;connect(portName, addr, &amp;pasynUserSyncIO_, drvInfo)) 
<a name="l00481"></a>00481             <span class="keywordflow">throw</span> std::runtime_error(std::string(<span class="stringliteral">&quot;pasynFloat64ArraySyncIO-&gt;connect failed&quot;</span>));
<a name="l00482"></a>00482     };
<a name="l00484"></a><a class="code" href="classasyn_float64_array_client.html#ae392abb25390692e5f530676eff798dd">00484</a>     <span class="keyword">virtual</span> <a class="code" href="classasyn_float64_array_client.html#ae392abb25390692e5f530676eff798dd" title="Destructor for asynFloat64Array class.">~asynFloat64ArrayClient</a>() {
<a name="l00485"></a>00485         pasynFloat64ArraySyncIO-&gt;disconnect(pasynUserSyncIO_);
<a name="l00486"></a>00486     };
<a name="l00491"></a><a class="code" href="classasyn_float64_array_client.html#a8fc0592c60e2a256314ef2964932297b">00491</a>     <span class="keyword">virtual</span> asynStatus <a class="code" href="classasyn_float64_array_client.html#a8fc0592c60e2a256314ef2964932297b" title="Reads an epicsFloat64 array from the port driver.">read</a>(epicsFloat64 *value, <span class="keywordtype">size_t</span> nElements, <span class="keywordtype">size_t</span> *nIn) {
<a name="l00492"></a>00492         <span class="keywordflow">return</span> pasynFloat64ArraySyncIO-&gt;read(pasynUserSyncIO_, value, nElements, nIn, timeout_);
<a name="l00493"></a>00493     };
<a name="l00497"></a><a class="code" href="classasyn_float64_array_client.html#a21517072a7d0c83ee3629289ae263805">00497</a>     <span class="keyword">virtual</span> asynStatus <a class="code" href="classasyn_float64_array_client.html#a21517072a7d0c83ee3629289ae263805" title="Writes an epicsFloat64 array to the port driver.">write</a>(epicsFloat64 *value, <span class="keywordtype">size_t</span> nElements) {
<a name="l00498"></a>00498         <span class="keywordflow">return</span> pasynFloat64ArraySyncIO-&gt;write(pasynUserSyncIO_, value, nElements, timeout_);
<a name="l00499"></a>00499     };
<a name="l00502"></a><a class="code" href="classasyn_float64_array_client.html#a79b1e163f38b88d25b69fb2357e34b57">00502</a>     <span class="keyword">virtual</span> asynStatus <a class="code" href="classasyn_float64_array_client.html#a79b1e163f38b88d25b69fb2357e34b57" title="Registers an interruptCallbackFloat64Array function that the driver will call when there is a new val...">registerInterruptUser</a>(interruptCallbackFloat64Array pCallback) { 
<a name="l00503"></a>00503         <span class="keywordflow">return</span> pInterface_-&gt;registerInterruptUser(pasynInterface_-&gt;drvPvt, pasynUser_,
<a name="l00504"></a>00504                                                   pCallback, <span class="keyword">this</span>, &amp;interruptPvt_); 
<a name="l00505"></a>00505     };
<a name="l00506"></a>00506 <span class="keyword">private</span>:
<a name="l00507"></a>00507     asynFloat64Array *pInterface_;
<a name="l00508"></a>00508 };
<a name="l00509"></a>00509 
<a name="l00510"></a>00510 
<a name="l00512"></a><a class="code" href="classasyn_generic_pointer_client.html">00512</a> <span class="keyword">class </span>epicsShareClass <a class="code" href="classasyn_generic_pointer_client.html" title="Class for asyn port clients to communicate on the asynGenericPointer interface.">asynGenericPointerClient</a> : <span class="keyword">public</span> <a class="code" href="classasyn_port_client.html" title="Base class for asyn port clients; handles most of the bookkeeping for writing an asyn port client wit...">asynPortClient</a> {
<a name="l00513"></a>00513 <span class="keyword">public</span>:
<a name="l00520"></a><a class="code" href="classasyn_generic_pointer_client.html#a103e9ae83513a148801a8a1ad972a908">00520</a>     <a class="code" href="classasyn_generic_pointer_client.html" title="Class for asyn port clients to communicate on the asynGenericPointer interface.">asynGenericPointerClient</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *portName, <span class="keywordtype">int</span> addr, <span class="keyword">const</span> <span class="keywordtype">char</span> *drvInfo, <span class="keywordtype">double</span> timeout=<a class="code" href="asyn_port_client_8h.html#aad2dd72565852b91c809cd4685833b17">DEFAULT_TIMEOUT</a>)
<a name="l00521"></a>00521     : <a class="code" href="classasyn_port_client.html" title="Base class for asyn port clients; handles most of the bookkeeping for writing an asyn port client wit...">asynPortClient</a>(portName, addr, asynGenericPointerType, drvInfo, timeout) {
<a name="l00522"></a>00522         pInterface_ = (asynGenericPointer *)pasynInterface_-&gt;pinterface;
<a name="l00523"></a>00523         if (pasynGenericPointerSyncIO-&gt;connect(portName, addr, &amp;pasynUserSyncIO_, drvInfo)) 
<a name="l00524"></a>00524             <span class="keywordflow">throw</span> std::runtime_error(std::string(<span class="stringliteral">&quot;pasynGenericPointerSyncIO-&gt;connect failed&quot;</span>));
<a name="l00525"></a>00525     };
<a name="l00527"></a><a class="code" href="classasyn_generic_pointer_client.html#a9d3fc0a31c7ba1c876ad3bf99ea4941a">00527</a>     <span class="keyword">virtual</span> <a class="code" href="classasyn_generic_pointer_client.html#a9d3fc0a31c7ba1c876ad3bf99ea4941a" title="Destructor for asynGenericPointer class.">~asynGenericPointerClient</a>() {
<a name="l00528"></a>00528         pasynGenericPointerSyncIO-&gt;disconnect(pasynUserSyncIO_);
<a name="l00529"></a>00529     };
<a name="l00532"></a><a class="code" href="classasyn_generic_pointer_client.html#a3b6250119e583e1c663da11f474658e5">00532</a>     <span class="keyword">virtual</span> asynStatus <a class="code" href="classasyn_generic_pointer_client.html#a3b6250119e583e1c663da11f474658e5" title="Reads an generic pointer from the port driver.">read</a>(<span class="keywordtype">void</span> *pointer) {
<a name="l00533"></a>00533         <span class="keywordflow">return</span> pasynGenericPointerSyncIO-&gt;read(pasynUserSyncIO_, pointer, timeout_);
<a name="l00534"></a>00534     };
<a name="l00537"></a><a class="code" href="classasyn_generic_pointer_client.html#a656d0ed4427db146c0c3e538ef6f84ab">00537</a>     <span class="keyword">virtual</span> asynStatus <a class="code" href="classasyn_generic_pointer_client.html#a656d0ed4427db146c0c3e538ef6f84ab" title="Writes a generic pointer to the port driver.">write</a>(<span class="keywordtype">void</span> *pointer) {
<a name="l00538"></a>00538         <span class="keywordflow">return</span> pasynGenericPointerSyncIO-&gt;write(pasynUserSyncIO_, pointer, timeout_);
<a name="l00539"></a>00539     };
<a name="l00542"></a><a class="code" href="classasyn_generic_pointer_client.html#ab90630640c5f11e0443a2d6f7c3d50b1">00542</a>     <span class="keyword">virtual</span> asynStatus <a class="code" href="classasyn_generic_pointer_client.html#ab90630640c5f11e0443a2d6f7c3d50b1" title="Registers an interruptCallbackGenericPointer function that the driver will call when there is a new v...">registerInterruptUser</a>(interruptCallbackGenericPointer pCallback) { 
<a name="l00543"></a>00543         <span class="keywordflow">return</span> pInterface_-&gt;registerInterruptUser(pasynInterface_-&gt;drvPvt, pasynUser_,
<a name="l00544"></a>00544                                                   pCallback, <span class="keyword">this</span>, &amp;interruptPvt_); 
<a name="l00545"></a>00545     };
<a name="l00546"></a>00546 <span class="keyword">private</span>:
<a name="l00547"></a>00547     asynGenericPointer *pInterface_;
<a name="l00548"></a>00548 };
<a name="l00549"></a>00549 
<a name="l00550"></a>00550 
<a name="l00552"></a><a class="code" href="classasyn_option_client.html">00552</a> <span class="keyword">class </span>epicsShareClass <a class="code" href="classasyn_option_client.html" title="Class for asyn port clients to communicate on the asynOption interface.">asynOptionClient</a> : <span class="keyword">public</span> <a class="code" href="classasyn_port_client.html" title="Base class for asyn port clients; handles most of the bookkeeping for writing an asyn port client wit...">asynPortClient</a> {
<a name="l00553"></a>00553 <span class="keyword">public</span>:
<a name="l00560"></a><a class="code" href="classasyn_option_client.html#a60b77bf5ba37e8ad90c97040fcba45c7">00560</a>     <a class="code" href="classasyn_option_client.html" title="Class for asyn port clients to communicate on the asynOption interface.">asynOptionClient</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *portName, <span class="keywordtype">int</span> addr, <span class="keyword">const</span> <span class="keywordtype">char</span> *drvInfo, <span class="keywordtype">double</span> timeout=<a class="code" href="asyn_port_client_8h.html#aad2dd72565852b91c809cd4685833b17">DEFAULT_TIMEOUT</a>)
<a name="l00561"></a>00561     : <a class="code" href="classasyn_port_client.html" title="Base class for asyn port clients; handles most of the bookkeeping for writing an asyn port client wit...">asynPortClient</a>(portName, addr, asynOptionType, drvInfo, timeout) {
<a name="l00562"></a>00562         pInterface_ = (asynOption *)pasynInterface_-&gt;pinterface;
<a name="l00563"></a>00563         if (pasynOptionSyncIO-&gt;connect(portName, addr, &amp;pasynUserSyncIO_, drvInfo)) 
<a name="l00564"></a>00564             <span class="keywordflow">throw</span> std::runtime_error(std::string(<span class="stringliteral">&quot;pasynOptionSyncIO-&gt;connect failed&quot;</span>));
<a name="l00565"></a>00565     };
<a name="l00567"></a><a class="code" href="classasyn_option_client.html#aece3fdf1648ebc4f458938c232c3ac48">00567</a>     <span class="keyword">virtual</span> <a class="code" href="classasyn_option_client.html#aece3fdf1648ebc4f458938c232c3ac48" title="Destructor for asynOption class.">~asynOptionClient</a>() {
<a name="l00568"></a>00568         pasynOptionSyncIO-&gt;disconnect(pasynUserSyncIO_);
<a name="l00569"></a>00569     };
<a name="l00574"></a><a class="code" href="classasyn_option_client.html#aabf1d6046f0d325a1a0025072f5a107a">00574</a>     <span class="keyword">virtual</span> asynStatus <a class="code" href="classasyn_option_client.html#aabf1d6046f0d325a1a0025072f5a107a" title="Get an option from the port driver.">getOption</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *key, <span class="keywordtype">char</span> *value, <span class="keywordtype">int</span> maxChars) {
<a name="l00575"></a>00575         <span class="keywordflow">return</span> pasynOptionSyncIO-&gt;getOption(pasynUserSyncIO_, key, value, maxChars, timeout_);
<a name="l00576"></a>00576     };
<a name="l00580"></a><a class="code" href="classasyn_option_client.html#a876caac188ac3eadd409e3384b405b2e">00580</a>     <span class="keyword">virtual</span> asynStatus <a class="code" href="classasyn_option_client.html#a876caac188ac3eadd409e3384b405b2e" title="Sets an option in the port driver.">setOption</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *key, <span class="keyword">const</span> <span class="keywordtype">char</span> *value) {
<a name="l00581"></a>00581         <span class="keywordflow">return</span> pasynOptionSyncIO-&gt;setOption(pasynUserSyncIO_, key, value, timeout_);
<a name="l00582"></a>00582     };
<a name="l00583"></a>00583 <span class="keyword">private</span>:
<a name="l00584"></a>00584     asynOption *pInterface_;
<a name="l00585"></a>00585 };
<a name="l00586"></a>00586 
<a name="l00587"></a>00587 
<a name="l00589"></a><a class="code" href="classasyn_enum_client.html">00589</a> <span class="keyword">class </span>epicsShareClass <a class="code" href="classasyn_enum_client.html" title="Class for asyn port clients to communicate on the asynEnum interface.">asynEnumClient</a> : <span class="keyword">public</span> <a class="code" href="classasyn_port_client.html" title="Base class for asyn port clients; handles most of the bookkeeping for writing an asyn port client wit...">asynPortClient</a> {
<a name="l00590"></a>00590 <span class="keyword">public</span>:
<a name="l00597"></a><a class="code" href="classasyn_enum_client.html#a8e8de509e72d0b95312e2553ef1939d5">00597</a>     <a class="code" href="classasyn_enum_client.html" title="Class for asyn port clients to communicate on the asynEnum interface.">asynEnumClient</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *portName, <span class="keywordtype">int</span> addr, <span class="keyword">const</span> <span class="keywordtype">char</span> *drvInfo, <span class="keywordtype">double</span> timeout=<a class="code" href="asyn_port_client_8h.html#aad2dd72565852b91c809cd4685833b17">DEFAULT_TIMEOUT</a>)
<a name="l00598"></a>00598     : <a class="code" href="classasyn_port_client.html" title="Base class for asyn port clients; handles most of the bookkeeping for writing an asyn port client wit...">asynPortClient</a>(portName, addr, asynEnumType, drvInfo, timeout) {
<a name="l00599"></a>00599         pInterface_ = (asynEnum *)pasynInterface_-&gt;pinterface;
<a name="l00600"></a>00600         if (pasynEnumSyncIO-&gt;connect(portName, addr, &amp;pasynUserSyncIO_, drvInfo)) 
<a name="l00601"></a>00601             <span class="keywordflow">throw</span> std::runtime_error(std::string(<span class="stringliteral">&quot;pasynEnumSyncIO-&gt;connect failed&quot;</span>));
<a name="l00602"></a>00602     };
<a name="l00604"></a><a class="code" href="classasyn_enum_client.html#addfe8cc48eb878e2c5c7efb76e086081">00604</a>     <span class="keyword">virtual</span> <a class="code" href="classasyn_enum_client.html#addfe8cc48eb878e2c5c7efb76e086081" title="Destructor for asynEnum class.">~asynEnumClient</a>() {
<a name="l00605"></a>00605         pasynEnumSyncIO-&gt;disconnect(pasynUserSyncIO_);
<a name="l00606"></a>00606     };
<a name="l00613"></a><a class="code" href="classasyn_enum_client.html#a81db5467a8bfb6fa2eb37b5b53c26745">00613</a>     <span class="keyword">virtual</span> asynStatus <a class="code" href="classasyn_enum_client.html#a81db5467a8bfb6fa2eb37b5b53c26745" title="Reads enum strings, values, and severities from the port driver.">read</a>(<span class="keywordtype">char</span> *strings[], <span class="keywordtype">int</span> values[], <span class="keywordtype">int</span> severities[], <span class="keywordtype">size_t</span> nElements, <span class="keywordtype">size_t</span> *nIn) {
<a name="l00614"></a>00614         <span class="keywordflow">return</span> pasynEnumSyncIO-&gt;read(pasynUserSyncIO_, strings, values, severities, nElements, nIn, timeout_);
<a name="l00615"></a>00615     };
<a name="l00621"></a><a class="code" href="classasyn_enum_client.html#a98f9922ae8cc8e31b5748e345d9c5efc">00621</a>     <span class="keyword">virtual</span> asynStatus <a class="code" href="classasyn_enum_client.html#a98f9922ae8cc8e31b5748e345d9c5efc" title="Writes enum strings, values, and severities to the port driver.">write</a>(<span class="keywordtype">char</span> *strings[], <span class="keywordtype">int</span> values[], <span class="keywordtype">int</span> severities[], <span class="keywordtype">size_t</span> nElements) {
<a name="l00622"></a>00622         <span class="keywordflow">return</span> pasynEnumSyncIO-&gt;write(pasynUserSyncIO_, strings, values, severities, nElements, timeout_);
<a name="l00623"></a>00623     };
<a name="l00624"></a>00624 <span class="keyword">private</span>:
<a name="l00625"></a>00625     asynEnum *pInterface_;
<a name="l00626"></a>00626 };
<a name="l00627"></a>00627 
<a name="l00628"></a>00628 
<a name="l00630"></a><a class="code" href="classasyn_common_client.html">00630</a> <span class="keyword">class </span>epicsShareClass <a class="code" href="classasyn_common_client.html" title="Class for asyn port clients to communicate on the asynCommon interface.">asynCommonClient</a> : <span class="keyword">public</span> <a class="code" href="classasyn_port_client.html" title="Base class for asyn port clients; handles most of the bookkeeping for writing an asyn port client wit...">asynPortClient</a> {
<a name="l00631"></a>00631 <span class="keyword">public</span>:
<a name="l00638"></a><a class="code" href="classasyn_common_client.html#af65c35c3efb3dd4dd2a2b18d715be292">00638</a>     <a class="code" href="classasyn_common_client.html" title="Class for asyn port clients to communicate on the asynCommon interface.">asynCommonClient</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *portName, <span class="keywordtype">int</span> addr, <span class="keyword">const</span> <span class="keywordtype">char</span> *drvInfo, <span class="keywordtype">double</span> timeout=<a class="code" href="asyn_port_client_8h.html#aad2dd72565852b91c809cd4685833b17">DEFAULT_TIMEOUT</a>)
<a name="l00639"></a>00639     : <a class="code" href="classasyn_port_client.html" title="Base class for asyn port clients; handles most of the bookkeeping for writing an asyn port client wit...">asynPortClient</a>(portName, addr, asynCommonType, drvInfo, timeout) {
<a name="l00640"></a>00640         pInterface_ = (asynCommon *)pasynInterface_-&gt;pinterface;
<a name="l00641"></a>00641         if (pasynCommonSyncIO-&gt;connect(portName, addr, &amp;pasynUserSyncIO_, drvInfo)) 
<a name="l00642"></a>00642             <span class="keywordflow">throw</span> std::runtime_error(std::string(<span class="stringliteral">&quot;pasynCommonSyncIO-&gt;connect failed&quot;</span>));
<a name="l00643"></a>00643     };
<a name="l00645"></a><a class="code" href="classasyn_common_client.html#ad27da490e66d98641b4e076042bfd436">00645</a>     <span class="keyword">virtual</span> <a class="code" href="classasyn_common_client.html#ad27da490e66d98641b4e076042bfd436" title="Destructor for asynCommon class.">~asynCommonClient</a>() {
<a name="l00646"></a>00646         pasynCommonSyncIO-&gt;disconnect(pasynUserSyncIO_);
<a name="l00647"></a>00647     };
<a name="l00651"></a><a class="code" href="classasyn_common_client.html#ae1c54da4cdff8b0d702e449d7e18f22a">00651</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classasyn_common_client.html#ae1c54da4cdff8b0d702e449d7e18f22a" title="Calls the report method in the driver.">report</a>(FILE *fp, <span class="keywordtype">int</span> details) {
<a name="l00652"></a>00652         pasynCommonSyncIO-&gt;report(pasynUserSyncIO_, fp, details);
<a name="l00653"></a>00653     };
<a name="l00655"></a><a class="code" href="classasyn_common_client.html#a841262fb9e38f844924058c529b4ce36">00655</a>     <span class="keyword">virtual</span> asynStatus <a class="code" href="classasyn_common_client.html#a841262fb9e38f844924058c529b4ce36" title="Calls the connect method in the driver which attempts to connect to the port device.">connect</a>() {
<a name="l00656"></a>00656         <span class="keywordflow">return</span> pasynCommonSyncIO-&gt;connectDevice(pasynUserSyncIO_);
<a name="l00657"></a>00657     };
<a name="l00659"></a><a class="code" href="classasyn_common_client.html#aac4273cf6c683e674fa4fbab46cd8eaa">00659</a>     <span class="keyword">virtual</span> asynStatus <a class="code" href="classasyn_common_client.html#aac4273cf6c683e674fa4fbab46cd8eaa" title="Calls the disconnect method in the driver disconnects from the port device.">disconnect</a>() {
<a name="l00660"></a>00660         <span class="keywordflow">return</span> pasynCommonSyncIO-&gt;disconnectDevice(pasynUserSyncIO_);
<a name="l00661"></a>00661     };
<a name="l00662"></a>00662 <span class="keyword">private</span>:
<a name="l00663"></a>00663     asynCommon *pInterface_;
<a name="l00664"></a>00664 };  
<a name="l00665"></a>00665     
<a name="l00666"></a>00666 <span class="preprocessor">#endif</span>
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Dec 11 2014 for asyn by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
